sdi2000292 Φωτόπουλος Δημήτριος Project 1 Syspro

main: Στην main κυρίως έχει υλοποιηθεί το parsing μέσα σε ένα συνεχόμενο loop που σπάει μόνο αν ο χρήστης δώσει
exit ή quit. Παίρνουμε μια πρόταση απο τον user την σπάμε σε tokens ελέγχοντας
τα κένα της πρότασης η το \n για νέα σειρά. Δημιουργούμαι ένα νέο char** το avv το οποίο περιλαμβάνει τα tokens.
Με το που δημιουργείται το avv το τοποθετούμαι στο history. Επίσης κάνουμε κάποιους ελέγχους για την λειτουργία του
history οι οποίες θα αναλυθούν καλύτερα οταν αναλυθεί το history. Θα επικεντρωθώ στο parsing στο παρόν σημείο. Το
επόμενο βήμα του parsing είναι η περίπτωση που έχουμε πολλά commands για bg και fg. Στην αρχή στα lines 127 με 147
γίνονται έλεγχοι για το πόσες bg εντολές υπάρχουν και αν υπάρχει fg εντολή. Μετά σε ένα νέο Loop γίνεται σπάσιμο
του avv σε av σε πλήθος ίσο με το άθροισμα των bg και fg εντολών. Με αυτό το loop κάθε command απο το σύνολο των command
που θα δώσει ο χρήστης κάνει το δικό της κύκλο. Έχοντας δημιουργήσει κάποια flags τα οποία ελέγχονται στο διάνυσμα av
πέρνουμε πληροφορίες για το διάνυσμα (πχ αν εχει redirections(input,output) / pipes /createalias κτλπ). Καποιες απο αυτές τις πληρο-
φορίες μας χρείαζονται στο επόμενο parsing που θα γίνει που θα δημιουργήσεις τις Commands που θα τρέξουν στις exec και
άλλες για αν θέλουμε να εκτελέσουμε κάποια άλλη λειτουργία. Το επόμενο parsing χωρίζει την εντολή av αναλόγως με το άμα έχει
pipes. (Πχ αν έχουμε av = ["cat gene_with_protein_product.txt" "|" "cut" "-f2" ">" "gene_with_protein_product_names_only_v2.txt" "NULL"] 
τότε θα δημιουργήσει Commands[0] = [ "cat" "gene_with_protein_product.txt" "NULL"] και το Command[1] = ["cut" "-f2" "NULL"]
και σαν output = ["gene_with_protein_product_names_only_v2.txt" ] ώστε να τρέξουν στα exec. Κρατιέται σε εναν πίνακα Counts το μέγεθος του
κάθε διανύσματος ώστε να μπορέσει να γίνει free. Αναλόγος με τα flags γίνονται και κάποιες άλλες ενέργειες τις οποίες θα επικεντρωθώ στο 
οταν συζητηθεί το αντίστοιχο κομμάτι. Μέσα στο Loops που χωρίζει fg και bg κάνω free των πίνακα διανυσμάτων Commands και του κάθε av.
Εκτός loop κάνω free τα υπόλοιπα που είναι το av καθώς και μια αντιγραφή του line που έχω δημιουργήσει.

redirections: Για να μπορέσουμε να υλοποιήσουμε τα redirections στον έλεγχο του av κρατάμε σε εναν πίνακα Input το input αν υπάρχει και σε
έναν πίνακα Output το output (Στο output υπάρχει ξεχωριστό flag αν είναι για append η όχι). Στον redirections.c υπάρχουν 4 συναρτήσεις παρό-
μοιες μία που τα κάνει όλα και input και output και append (αυτή μας χρησιμεύει στην περίπτωση εντολής χωρίς pipes με input και output or append.)
καθώς και χωριστά μια συνάρτηση για input αλλη μία για output και άλλη μια για append. (αυτές έχουν υλοποιθεί χωριστά γιατί σε περίπτωση pipes ο
κώδικας ελέγχει στην πρώτη εντολή αν υπαρχει input και στην τελευταία αν υπάρχει output or append.). Σε περίπτωση input ανοίγει το αρχείο για read
only και μέσω της dup2 ανακατευθύνει το stdin να "κοιτάει" στο αρχείο.(Θα αναλυθεί λίγο περισσότερο μέτα με τις exec πως λειτουργεί). Σε περίπτωση
output or append αλλάζουν τα flags στην open σε wright only , create αν δεν υπάρχει , και στην append σε O_APPEND το τελευταίο flag που είναι για 
επέκταση και στην output για αντικατάσταση που είναι το flag Ο_ΤRUNC. Και στις δύο περιπτώσεις(output , append), μέσω της dup2 ανακατευθύνουμε το stdout(1)
στον φάκελο. Σε όλες τισ συναρτήσεις στην αρχή γίνεται έλεγχος αν το αντίστοιχο flag έχει ενεργοποιηθεί. 

Pipes: Τα pipes υλοποιούνται στον φάκελο exec.c σε συνάρτηση με το parsing των Commands που έχει χωρίσει τις εντολές για την κάθε exec στην main και τα αντιστοιχα flags. Σε περίπτωση
που δεν έχει δωθεί εντολή με pipes η chooseExec καλεί την exec1. Εκεί δημιουργεί μέσω της Fork μια διεργασία για την exec. Πριν την exec μέσω της 
ενιαίας συνάρτησης redi που αναλύθηκε παραπάνω ανακατευθύνει την έισοδο και την έξοδο της exec( Η exec dflt έχει σαν είσοδο Stdin(0) και έξοδο Stdout(1))
άρα στην περιπτωσή μας ανακατευθύνουμε το output και το input στα αρχεία (αν υπάρχουν). Σε περίπτωση που υπάρχουν pipes στην εντολή η chooseexec παει στην 2η
συνάρτηση την execpipes(η συγκεκριμένη συνάρτηση λειτουργεί για οσα pipes βάλει ο χρήστης). Σε αυτήν την συνάρτηση τα pipes υλοποιούνται στην σειρά μέσω ενος
loop που στην ουσία μέσω pipes το output της μία διεργασίας περνάει σαν input στην επόμενη διεργασία(exec). Δηλαδή η πρώτη exec παίρνει σαν input το stdin η το
αρχείο σε περίπτωση redirections μέσω pipe στέλνει το output στην επόμενη διεργασία , οι "μεσαίες" exec παίρνουν input απο την προηγούμενη και δίνουν output
στην επόμενη και η τελευταία exec στο loop παίρνει input απο την προτελευταία και δίνει output η στο stdout η σε φάκλεο σε περίπτωση redirection. Πιο αναλυτικά
έχουμε τον αριθμό των Commands ως Number of Commands ξέρουμε ότι είναι τουλάχιστον 2 οπότε δημιουργούμαι έναν πινακα απο Pids οσα τα Commands και εναν πίνακα
απο pipes οσα τα Commands-1(χρειαζόμαι ενα λιγότερο pipe απο όσα τα commands γιατί ενα pipe συνδέει 2 commands). Για κάθε Pid καλούμε fork δημιουργόυμε μια
νεα διεργασία τρέχουμε την exec με τα κατάλληλα redirections όπως αναλύθηκε παραπάνω μέσω dup2(Η θα κοιτάει η exec σε αρχειο η στο default η σε pipe για να
παρει απο την προηγουμενη exec και να δώσει στην επόμενη). Σε κάθε διεργασία κλείνουμε τα pipes που δεν χρειαζόμαστε και αυτο που χρησιμοποιουμε μετα απο την 
ανακατευθυνση μέσω της dup2. Στην μαμά περιμένουμε ολες τις διεργασίες και κλείνουμε και ολα τα pipes. Στην main για κάθε εναν κύκλο εντολής δημιουργούμαι μια
νέα διεργασία (για fg η bg αντίστοιχα) και σαν δικλύδα ασφαλείας αλλα και για καλύτερο έλεγχο(Βοηθάει και στην υλοποίηση των Signals). 

History: Το history είναι ενα struck που περιλαμβάνει έναν πίνακα απο δείκτες Struct Histor 20 θέσεων και εναν ακέραιο (ο οποίος κρατάει πόσες θέσεις
είναι κατελλημένες). Το Struct histor έχει έναν δείκτη σε δίανυσμα εναν ακέραιο για το μήκος του και τον αριθμό πού είναι αυτό το struct.
(τα παραπάνω struct ορίζονται στο def.h που περιλαμβάνει τα πρωτότυπα όλων των συναρτήσεων, τις βιβλιοθήκες και ολα τα struct). Απο τις
συναρτήσεις στο history.c κάνουμε τις αντίστοιχες ενέργειες οπώς εισαγωγή print delete(Free) κτλπ. Η υλοποίηση του history στην main υλοποιήται 
στην αρχή με το δίανυσμα avv και στο ίδιο σημείο γίνεται αν θέλουμε να καλέσουμε κάποια εντολή απο το history αντικαθιστώντας το διανυσμα avv με 
αυτό που δίνει το history καθώς και το μήκος του avv με το μήκος της εντολής ώστε να γίνει κατάλληλο free. Το struct History το κάνω free κανοντας
free την κάθε θέση του στο τέλος του προγράμματος και αντίστοιχα free για το aliaslist και κάθε μία θέση του.

Alias: Για το alias παρόμοια με το history δημιουργόυμε 2 struct. Το 1ο Struck είναι το Alias που κρατάει το όνομα του alias (πχ στην εντολη createalias sor "sort -r -d" το name
περιλαμβάνει το sor (μέσω δεικτών και ξεχωριστής δημιουργίας) το command θα είναι το [sort] [-r] [-d] και το num_in_com θα είναι 3 ώστε να γνωρίζουμε πόσο θα μεγαλώσουμε το διανυσμα
Command οταν γίνει η αντικατάσταση. Με τις αντίστοιχες συναρτήσεις στο alias.c κάνουμε τις αντιστοιχές ενέργειες. Η υλοποίηση του alias στην main γίνεται στο parsing των Commands στην 
περίπτωση αντικατάστασης και ελέγχοντας τα κατάλληλα flags για να μην συνδιαστεί με καμία άλλη εντολή που δεν πρέπει να φτάσει σε αυτό το επίπεδο που τρέχει στις exec πχ σε περίπτωση createalias
or destroyalias. Τα creatalias και destroyalias με τα κατάλληλα flags ενεργοποιούνται μετα απο τα Commands κάνοντας τα αντίστοιχα μέσω των συναρτήσεων που έχουν οριστεί στην στο alias.c.

WildCards: Οσο να αφορά τα wildcards μέσω της βιβλιοθήκης <glob.h> ελέγχουμε κάθε λέξη για κάθε Commands[i] διάνυσμα μέσω της συνάρτησης strpbrk έλέγχουμε αν υπάρχει κάποιο wildcard symbol.
Σε περίπτωση που υπάρχει παίρνουμε τα παραπάνω ορίσματα μέσω της glob και τα περνάμε στο commands που το αλλάζουμε μέγεθος και επιστρέφω το μέγεθος μέσω αναφοράς ώστε να γίνουν τα κατάλληλα free.
Ο κώδικας υπάρχει στην συνάρτηση wildcards.c. Στην main υλοποίηται οταν έχουμε ετοιμάσει τα commands πριν τα στειλουμε στην εκτέλεση των exec.

Signals: Στα σήματα η μαμά αγνοεί Cnt-C / Cnt-Z. Οσο να αφορά τα παιδιά δέχονται το Cnt-C αλλα δεν μπόρεσα να καταφέρω να ξαναγυρνάει στο loop καθώς επισης και οταν μπαίνει σε pause να συνεχίζει το
loop. Στο cntl -c υπάρχουν κάποιοι handlers που με την βοήθεια σηματοφόρων προσπαθούν να το πετύχουν αλλά χωρίς αποτέλεσμα.
   




  